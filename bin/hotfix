#!/usr/bin/env ruby
require_relative '../lib/signal_handlers.rb'
require_relative '../lib/github.rb'
require_relative '../lib/git.rb'
require_relative '../lib/helpers.rb'

command=ARGV.first

$0 = ARGV.join(" ")

unless command == '--help' or command == '-h'
   unless Git::in_a_repo
      die("\nSwitch to a git repo. If you need help, use --help or -h.")
   end
end

case command
when 'start'
   require_argument(:hotfix, :start)
   hotfix = hotfix_branch(ARGV[1])
   stable_branch = Git::get_branch('stable')

   exit unless confirm("Create hotfix branch named: '#{hotfix}' ?")

   Git::run_safe([
      "git checkout #{stable_branch}",
      "git pull --rebase",
      "git branch \"#{hotfix}\" #{stable_branch}",
      "git checkout \"#{hotfix}\""
   ])

   Git::submodules_update

   # Automatically setup remote tracking branch
   Git::run_safe([
      "git config branch.#{hotfix}.remote origin",
      "git config branch.#{hotfix}.merge refs/heads/#{hotfix}",
      "git config branch.#{hotfix}.rebase true"
   ])

when 'url'
   require_argument(:hotfix, :url, min=1, max=2)
   hotfix = ARGV[1] || Git::current_branch

   url = Github::get_url(hotfix)
   if url
      puts url
   else
      abort "There is no pull request available for #{hotfix}.\n" +
            'You can make one by using `hotfix finish`.'
   end


when 'switch'
   require_argument(:hotfix, :switch, min=2, max=5)
   hotfix = current_hotfix_branch

   Git::switch_branch(hotfix)

   optional_pull

when 'finish'
   hotfix = current_hotfix_branch

   if !is_hotfix_branch feature
      abort "This is a feature branch.  Please use feature-finish."
   end

   # Push commits to origin
   Git::run_safe(["git push origin #{hotfix}:#{hotfix}"])

   exit 1 unless confirm("Create a pull-request for hotfix branch named: '#{hotfix}' ?")
   octokit = Github::api

   description = Github::get_pull_request_description(hotfix)
   puts "Pull-request description:"
   puts description[:title]
   puts "#"
   puts description[:body]

   response = octokit.create_pull_request(
      Github::get_github_repo,
      Git::get_branch('stable'),
      hotfix,
      description[:title],
      description[:body]
   )

   puts "Successfully created pull-request ##{response[:number]}"
   puts "   " + response[:html_url]

when 'finish-issue'
   require_argument(:hotfix, :'finish-issue')
   issue = ARGV[1]
   hotfix = Git::current_branch

   if !is_hotfix_branch feature
      abort "This is a feature branch.  Please use feature-finish-issue."
   end

   # Push commits to origin
   Git::run_safe(["git push origin #{hotfix}:#{hotfix}"])

   exit 1 unless confirm("Convert issue ##{issue} into a pull-request using " +
    "hotfix branch named '#{hotfix}' ?")
   octokit = Github::api

   pull = octokit.create_pull_request_for_issue(
      Github::get_github_repo,
      Git::get_branch('stable'),
      hotfix,
      issue
   )

   # We've converted the issue to a pull request, now lets change the
   # description to include the last commit message and prompt the user to
   # confirm it.

   last_commit_message = Git::commit_message(hotfix)

   original_title = pull[:title].gsub("\r","")
   original_body = pull[:body].gsub("\r","")

   initial_message = <<-MESSAGE
#{last_commit_message}

----

Original issue: #{original_title}
----

#{original_body}
   MESSAGE

   description = Github::open_title_body_editor(initial_message)

   updated_pull = octokit.update_pull_request(
      Github::get_github_repo,
      issue,
      description[:title],
      description[:body]
   )

   puts "Successfully converted issue ##{issue} to a pull-request"
   puts "   " + updated_pull[:html_url]

when 'merge'
   fail_on_local_changes
   dev_branch = Git::get_branch('development')
   stable_branch = Git::get_branch('stable')
   hotfix = current_hotfix_branch

   if !is_hotfix_branch hotfix
      exit 1 unless confirm("It looks like this is a feature branch.  Are you sure you want to merge it into #{stable_branch}?")
   end

   Git::run_safe(["git fetch"])

   pull_info = Github::get_pull_request_info_from_api(hotfix, stable_branch)

   warning = Github::get_commit_status_warning(pull_info[:status])
   unless warning.empty?
      puts highlight(warning)
   end

   exit 1 unless confirm("Merge hotfix named: '#{hotfix}' ?")

   commit_message = Git::get_description_from_user(pull_info[:description])
   commit_message_dev = commit_message.sub(stable_branch, dev_branch)

   update = Git::submodules_update("get")

   Git::run_safe([
      # Checkout the branch to make sure we have it locally.
      "git checkout #{hotfix.shellescape}",
      "git rebase --preserve-merges origin/#{hotfix.shellescape}",
      # Merge into stable.
      "git checkout #{stable_branch}",
      # Pull the latest changes and rebase the unpushed commits if any.
      "git rebase --preserve-merges origin/#{stable_branch}",
      # Merge the hotfix branch into stable.
      "git merge --no-ff --no-edit -m #{commit_message.shellescape} \"#{hotfix}\"",
      "#{update}",
      # Merge into master.
      "git checkout #{dev_branch}",
      # Pull the latest changes and rebase the unpushed master commits if any.
      "git rebase origin/#{dev_branch}",
      # Merge the hotfix branch into master.
      "git merge --no-ff --no-edit -m #{commit_message_dev.shellescape} \"#{hotfix}\"",
      # Init any submodules in the master branch. Note: no need to change.
      # Directories before calling git submodule since we are already in the
      # projects top-level directory.
      "#{update}",
      # Delete the local hotfix branch.
      "git branch -d #{hotfix.shellescape}",
      # Checkout stable branch.
      "git checkout #{stable_branch}"
   ])

   puts "Successfully merged hotfix branch: #{hotfix} into #{stable_branch} and #{dev_branch}"
   puts "If you are satisfied with the result, do this:\n" + <<CMDS
      git push
      git checkout #{dev_branch}
      git push
CMDS

when 'list'
   options = {
      :hotfix => Git::hotfix_branches(:unmerged)
   }
   if ARGV.include?('-v')
      options[:merged] = Git::hotfix_branches(:merged)
   end
   Git.show_branch_list(options)
else
   display_hotfix_help
end

log_command("hotfix #{$0}")
