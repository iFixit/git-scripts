#!/usr/bin/env ruby
require_relative '../lib/signal_handlers.rb'
require_relative '../lib/github.rb'
require_relative '../lib/git.rb'
require_relative '../lib/helpers.rb'
require 'optparse'
require 'rubygems'
require 'table_print'

def populate_table_row(login, user = nil)
   {
      'login'        => login,
      'count'        => user ? user['count'] : 0,
      'score'        => user ? user['score'][ALL] : 0,
      'ready'        => user ? user['score'][READY] : 0,
      'in_progress'  => user ? user['score'][IN_PROGRESS] : 0,
      'under_review' => user ? user['score'][UNDER_REVIEW] : 0,
   }
end

options = {}
OptionParser.new do |opts|
   opts.banner = 'Usage: workload [OPTIONS]'
   opts.separator ''
   opts.separator 'Analyzes issue workload per person and milestone'
   opts.separator ''
   opts.separator 'Example: workload [OPTIONS] --repo="ifixit/git-scripts" --milestones="Guide i18n"'
   opts.separator ''

   opts.on('-m', '--milestones [TITLE1, ...]', Array, 'Filter down to issues within milestones') do |milestones|
      options[:milestones] = milestones
   end

   opts.on('-e', '--exclude [LABEL]', String, 'Exclude issues with this label') do |label|
      options[:exclude] = label
   end

   opts.on('-s', '--sortby [CATEGORY]', String, 'Sort by ready|in_progress|under_review') do |category|
      options[:sortby] = category
   end

   opts.on('-r', '--repo [NAME]', String, "Defaults to the repo the script is executed within") do |repo|
      options[:repo] = repo
   end

   opts.on('-t', '--teams [TEAM1, ...]', Array, "Teams' users to include in results") do |teams|
      options[:teams] = teams
   end
end.parse!

repo = options[:repo] || Github.get_github_repo

ALL = 'all'
READY = 's-Ready'
IN_PROGRESS = 'In Progress'
UNDER_REVIEW = 's-Under Review'

filters = {}
issues = []

if options[:milestones]
   milestones = Github.api.list_milestones(repo, {
      :state => 'open',
   })
   milestones = milestones.select do |m|
      options[:milestones].include?(m.title)
   end

   milestoneNums = milestones.map { |m| m.number }

   # The Issues endpoint only accepts one milestone, so we have to iterate.
   milestoneNums.each do |m|
      filters[:milestone] = m
      issues << Github.api.list_issues(repo, filters)
      issues.flatten!.uniq!
   end
else
   # If no milestone is specified.
   issues = Github.api.list_issues(repo, filters)
end

teamLogins = []

if options[:teams]
   teams = Github.api.org_teams('iFixit').select do |team|
      options[:teams].include?(team['name'])
   end

   teams.each do |team|
      teamLogins << Github.api.team_members(team['id']).map! { |user| user.login }
      teamLogins.flatten!.uniq!
   end
end

users = {}

issues.each do |issue|
   next unless issue['assignee']

   labels = issue['labels'].map { |l| l['name'] }

   next if labels.include?(options[:exclude])

   login = issue['assignee']['login']
   users[login] = {} if users[login].nil?
   user = users[login]

   user['count'] = 0 if user['count'].nil?
   if user['score'].nil?
      user['score'] = {}
      s = user['score']
      s[ALL] = s[READY] = s[IN_PROGRESS] = s[UNDER_REVIEW] = 0
   end

   labels.each do |label|
      if label.to_i != 0
         score = label.to_i

         user['score'][ALL] += score
         if labels.include?(READY)
            user['score'][READY] += score
         elsif labels.include?(IN_PROGRESS)
            user['score'][IN_PROGRESS] += score
         elsif labels.include?(UNDER_REVIEW)
            user['score'][UNDER_REVIEW] += score
         end
         break
      end
   end

   user['count'] += 1
end

rows = []

users.each_pair do |login, user|
   rows << populate_table_row(login, user)
end

# If team(s) are specified filter results to members of those teams.
if options[:teams]
   # Populate table rows for teams' users who don't have any issues.
   teamLogins.each do |login|
      unless users.keys.include?(login)
         rows << populate_table_row(login)
      end
   end

   # Filter out users with issues who aren't on teams.
   rows.select! do |row|
      teamLogins.include?(row['login'])
   end
end

sort_by = options[:sortby] || 'score'
rows.sort! do |a, b|
   b[sort_by] <=> a[sort_by]
end

tp.set(:max_width, 80)
tp rows
